{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Adaptable code This talk is focused on backend and its examples are using Laravel. The concepts will translate to any framework and probably applicable to frontend too. I'm using MKdocs so it can serve as both a presentation (with syntax highlighting) and later reference. What is the goal of this talk? It's meant to inform and inspire. It's not meant to imply anything must be done like this. After this I'd also really like to hear of any other approaches to similar problems.","title":"Home"},{"location":"#adaptable-code","text":"This talk is focused on backend and its examples are using Laravel. The concepts will translate to any framework and probably applicable to frontend too. I'm using MKdocs so it can serve as both a presentation (with syntax highlighting) and later reference.","title":"Adaptable code"},{"location":"#what-is-the-goal-of-this-talk","text":"It's meant to inform and inspire. It's not meant to imply anything must be done like this. After this I'd also really like to hear of any other approaches to similar problems.","title":"What is the goal of this talk?"},{"location":"0-look-at-this/","text":"Example case Let's say you have a view that will show you some people from a remote source filtered by some scope (a group, for this example). These people come from Microsoft. namespace App\\Controllers; use App\\Models\\Group; use Illuminate\\Http\\Response; use Illuminate\\Routing\\Controller; class RemotePersonController extends Controller { public function index(Group $group, \\Microsoft\\Graph\\Graph $client): Response { $accessToken = 'totally-valid-token'; // pretend-this-has-valid origin /** @var \\Microsoft\\Graph\\Model\\User[] $users */ $users = $client->createRequest('GET', '/people?$filter=groupId eq ' . $group->remote_id) // pretend this is a valid filter ->setAccessToken($accessToken) ->setReturnType(\\Microsoft\\Graph\\Model\\User::class) ->execute(); $people = collect($users)->pluck('displayName', 'id'); return response()->view('person.index', ['people' => $people]); } } What can you think of that you would do differently to this implementation? Shoot.","title":"Look at this"},{"location":"0-look-at-this/#example-case","text":"Let's say you have a view that will show you some people from a remote source filtered by some scope (a group, for this example). These people come from Microsoft. namespace App\\Controllers; use App\\Models\\Group; use Illuminate\\Http\\Response; use Illuminate\\Routing\\Controller; class RemotePersonController extends Controller { public function index(Group $group, \\Microsoft\\Graph\\Graph $client): Response { $accessToken = 'totally-valid-token'; // pretend-this-has-valid origin /** @var \\Microsoft\\Graph\\Model\\User[] $users */ $users = $client->createRequest('GET', '/people?$filter=groupId eq ' . $group->remote_id) // pretend this is a valid filter ->setAccessToken($accessToken) ->setReturnType(\\Microsoft\\Graph\\Model\\User::class) ->execute(); $people = collect($users)->pluck('displayName', 'id'); return response()->view('person.index', ['people' => $people]); } } What can you think of that you would do differently to this implementation?","title":"Example case"},{"location":"0-look-at-this/#shoot","text":"","title":"Shoot."},{"location":"1-first-separation/","text":"Perhaps you prefer to wrap the MS client because you want it to reflect our use case more instead of reflect a Graph API client. class RemotePersonController extends Controller { public function index(Group $group, \\App\\Clients\\Microsoft $client): Response { $accessToken = config('pretend-this-is-always-valid'); /** @var Collection<\\Microsoft\\Graph\\Model\\User> $people */ $users = $client->listUsersInGroup($accessToken, $group); $people = $users->pluck('displayName', 'id'); return response()->view('person.index', ['people' => $people]); } } But now, let's say a requirement for connecting to Google instead of Microsoft is introduced, and (for this example) Google might not call them users. Since we're looking for people not users, we can make interfaces use Person instead of User. We don't need the conversion of users to people in the controller anymore, since the clients are responsible for that class RemotePersonController extends Controller { public function index(Group $group, ClientInterface $client): Response { $people = $client->listPeopleInGroup($accessToken, $group); return response()->view('person.index', ['people' => $people]); } } interface ClientInterface { /** @return PersonDto[] $people */ public function listPeopleInGroup(string $accessToken, Group $group): array; } class \\App\\Clients\\Microsoft implements ClientInterface { ... } class \\App\\Clients\\Google implements ClientInterface { ... }","title":"First separation"},{"location":"10-mocks-vs-fakes/","text":"Using an interface makes it easier to make tests independent of remote connections. You could mock dependencies of course, but there are some disadvantages: Each test (case) is responsible for setting up both expectations and return values It might accept incorrect arguments or return incorrect Too many mocking might lead to a test only testing itself instead of production code {TODO: Try to think of a concrete example here} class RemotePersonControllerTest extends TestCase { /** @test */ public function it_retrieves_people_from_remote(): void { $clientMock = $this->mock(ListRemotePeopleInterface::class); $clientMock ->expects() ->getLicensesForPerson() ->andReturn([ new Dto\\License('all', 'constructor', 'args'), new Dto\\License('some', 'more', 'args'), ]); } } Fakes are another type of test doubles. They are not mocks, but they \"actually\" work, but usually in a simplified case. In teams I've worked with, we usually called them Fake , but it is also common to namespace or prefix it as InMemory , or even Database . This example just lists the people, or licenses already stored. namespace \\App\\Clients\\Database; class ListPeopleClient implements ListRemotePeopleClient { public function __construct(private readonly string $validAccessToken): { } public function getPeopleInGroup(string $accessToken, Group $person): array { Assert::eq($accessToken, $this->validAccessToken, 'Invalid access token'); Assert::keyExists($person->some_identifier, $this->validAccessToken, 'Unknown group'); $localPeople = Person::whereHasGroup($group) ->whereNotNull('some_identifier') ->get(); $remotePeople = $localPeople->map($this->someTransformation(...)); // still just go with it return $remotePeople; } } namespace \\App\\Clients\\Database; class ListLicenseClient implements ListRemoteLicenseClient { public function __construct(private readonly string $validAccessToken): { } public function getLicensesForPerson(string $accessToken, Person $person): array { Assert::eq($accessToken, $this->validAccessToken, 'Invalid access token'); Assert::keyExists($person->some_identifier, $this->validAccessToken, 'Unknown person'); $localLicenses = $person->licenses; $remoteLicenses = $localLicenses->map($this->someTransformation(...)); return $remoteLicenses; } }","title":"Testing: Mocks vs Fakes"},{"location":"11-mutability-fakes/","text":"Previous example will not work correctly when we expect an update to also be persisted on the remote, but shouldn't change anything locally. Now, what if you want things to be persisted, at least during your tests. Sorry, Not ready namespace \\App\\Clients\\InMemory; class PeopleClient implements ListRemotePeopleClientInterface, EditRemotePersonClient { /** @var Collection<string, Collection<Dto\\Person>> */ private Collection $remotePeopleInGroups; public function __construct(private readonly string $validAccessToken): { $this->remotePeopleInGroups = Groups::whereNotNull('some_identifier') ->mapWithKeys(fn (Group $group) => [ $group->some_identifier => $group->people->map($this->someTransformation(...)); // still going with it? ]); } public function getPeopleInGroup(string $accessToken, Group $group): array { Assert::eq($accessToken, $this->validAccessToken, 'Invalid access token'); Assert::true($this->remotePeopleInGroups->has($group->some_identifier), 'Unknown group'); } public function createPerson(string $accessToken, PersonDto $person): Person { ... } public function deletePerson(string $accessToken, PersonDto $person): bool { ... } public function updatePerson(string $accessToken, PersonDto $person): bool { ... } public function createPerson(string $accessToken, PersonDto $person): Person { ... } }","title":"Testing: Support mutability in fakes"},{"location":"12-outro/","text":"Conclusion This talk was just about interfaces. But that's not a catchy title. For those who are not a fan, Summary When introducing interfaces When do you introduce an interface? Always. No, not really. It depends on how interchangeable it likely will be. In case of a client for a remote source, I do it by default, because I'd like to be able to make an offline/in memory version Even if you don't think the remote source will change, API's can change, so you could have an implementation for both versions in a transition period. More than once in my something was \"only needed from remote X\", to later be asked to add it for remote Y too. And sometimes even during development of X I needed to pivot to Y Even during development, I'd like to ask myself this question: If for a specific situation (but not all), some part needs other conditions, another remote source, another remote destination, How much of the application code do I need to change? Try to make those parts separate dependencies (if they aren't already) and try to define them as interfaces. In other words: can you make the application plug & play while maintaining its basic flow/business rules regardless of the implementations? When do you split up your interface? Decide whether all implementations will definitely need to implement all methods, if not: split up. Are you sure the interface serves a single purpose, or is it just that your current intended implementation does all these things? \"But when all dependencies are interfaces, I can not see what it does!\" Yes you can. class CardDeck { public function __( private array $cards; private readonly RandomNumberGeneratorInterface randomNumberGenerator ){ } public function drawCard(): Card { $index = $this->randomNumberGenerator->getRandomNumberBelow(count($cards)); $this->cards = array_slice($this->cards, $index, 1) } } If you see a dependency is called RandomNumberGeneratorInterface and a method is called getRandomNumber() Do you really need to see the source? That is only relevant when fixing that dependency, but if that's not reported broken you better believe it returns a random number. Thoughts?","title":"Final thoughts"},{"location":"12-outro/#conclusion","text":"This talk was just about interfaces. But that's not a catchy title. For those who are not a fan,","title":"Conclusion"},{"location":"12-outro/#summary","text":"When introducing interfaces","title":"Summary"},{"location":"12-outro/#when-do-you-introduce-an-interface","text":"Always. No, not really. It depends on how interchangeable it likely will be. In case of a client for a remote source, I do it by default, because I'd like to be able to make an offline/in memory version Even if you don't think the remote source will change, API's can change, so you could have an implementation for both versions in a transition period. More than once in my something was \"only needed from remote X\", to later be asked to add it for remote Y too. And sometimes even during development of X I needed to pivot to Y Even during development, I'd like to ask myself this question: If for a specific situation (but not all), some part needs other conditions, another remote source, another remote destination, How much of the application code do I need to change? Try to make those parts separate dependencies (if they aren't already) and try to define them as interfaces. In other words: can you make the application plug & play while maintaining its basic flow/business rules regardless of the implementations?","title":"When do you introduce an interface?"},{"location":"12-outro/#when-do-you-split-up-your-interface","text":"Decide whether all implementations will definitely need to implement all methods, if not: split up. Are you sure the interface serves a single purpose, or is it just that your current intended implementation does all these things?","title":"When do you split up your interface?"},{"location":"12-outro/#but-when-all-dependencies-are-interfaces-i-can-not-see-what-it-does","text":"Yes you can. class CardDeck { public function __( private array $cards; private readonly RandomNumberGeneratorInterface randomNumberGenerator ){ } public function drawCard(): Card { $index = $this->randomNumberGenerator->getRandomNumberBelow(count($cards)); $this->cards = array_slice($this->cards, $index, 1) } } If you see a dependency is called RandomNumberGeneratorInterface and a method is called getRandomNumber() Do you really need to see the source? That is only relevant when fixing that dependency, but if that's not reported broken you better believe it returns a random number.","title":"\"But when all dependencies are interfaces, I can not see what it does!\""},{"location":"12-outro/#thoughts","text":"","title":"Thoughts?"},{"location":"2-separate-interfaces-subject/","text":"A concept called Licenses is introduced, so we add a license method to the client interface class RemoteLicenseController extends Controller { public function index(App\\Person $person, ClientInterface $client): Response { $licenses = $client->getLicensesForPerson($accessToken, $person); return response()->view('license.index', ['licenses' => $licenses]); } } interface ClientInterface { /** @return PersonDto[] */ public function getPeopleInGroup(string $accessToken, Group $group): array; /** @return LicenseDto[] */ public function getLicensesForPerson(string $accessToken, Group $group): array; } class \\App\\Clients\\Microsoft implements ClientInterface { ... } class \\App\\Clients\\Google implements ClientInterface { ... } But, our customer using Google people uses Licenses from a different source, for example AFAS. We actually don't have a case for Google Licenses at the moment. So, we split them up per subject: interface RemotePersonClientInterface { /** @return LicenseDto[] $licenses */ public function getPeopleInGroup(string $accessToken, Group $group): array; } interface RemoteLicensesClientInterface { /** @return LicenseDto[] $licenses */ public function getLicensesForPerson(string $accessToken, Person $person): array; } class \\App\\Clients\\Microsoft implements RemotePersonClientInterface, RemoteLicensesClientInterface { ... } class \\App\\Clients\\Google implements RemotePersonClientInterface { ... } class \\App\\Clients\\Afas implements RemoteLicensesClientInterface { ... }","title":"Second separation"},{"location":"3-separate-interfaces-functionality/","text":"Jump in time, we have all remote CRUD methods now, so we have a controller like this class RemoteLicenseController extends Controller { public function index(App\\Person $person, RemotePersonClientInterface $client): Response { ... } public function create(): Response { .. } public function store(Request $request, RemotePersonClientInterface $client): Response { $accessToken = ... $licenseDto = $this->someTransformation($request); // just go with it ... $license = $client->createLicense($accessToken, $licenseDto); return response()->redirect('license.index'); } public function edit(): Response { .. } public function update(Request $request, RemotePersonClientInterface $client): Response { .. } } We update our client interfaces accordingly: interface RemotePersonClientInterface { public function createPerson(string $accessToken, PersonDto $person): Person; public function updatePerson(string $accessToken, PersonDto $person): bool; public function deletePerson(string $accessToken, PersonDto $person): bool; /** @return PersonDto[] $people */ public function getPeopleInGroup(string $accessToken, Group $group): array; } interface RemoteLicensesClientInterface { public function createLicense(string $accessToken, LicenseDto $license): License; public function updateLicense(string $accessToken, LicenseDto $license): bool; public function deleteLicense(string $accessToken, LicenseDto $license): bool; public function assignLicenseToPerson(string $accessToken, Person $person, LicenseDto $license): bool; public function removeLicenseFromPerson(string $accessToken, Person $person, LicenseDto $license): bool; /** @return LicenseDto[] $licenses */ public function getLicensesForPerson(string $accessToken, Person $person): array; } But, when we want to implement those methods, we realize we don't want to support CRUD methods for AFAS Licenses, nor for Google People. All customers using those, handle their updating outside of our application, not much sense writing support for it just to comply with the interfaces. We can split up the interfaces for their specific use cases interface ListRemotePeopleClientInterface { /** @return PersonDto[] $people */ public function getPeopleInGroup(string $accessToken, Group $group): array; } interface ListRemoteLicensesClientInterface { /** @return LicenseDto[] $licenses */ public function getLicensesForPerson(string $accessToken, Person $person): array; } interface EditRemotePersonClientInterface { public function createPerson(string $accessToken, PersonDto $person): Person; public function updatePerson(string $accessToken, PersonDto $person): bool; public function deletePerson(string $accessToken, PersonDto $person): bool; } interface EditRemoteLicenseClientInterface { public function createLicense(string $accessToken, LicenseDto $license): License; public function updateLicense(string $accessToken, LicenseDto $license): bool; public function deleteLicense(string $accessToken, LicenseDto $license): bool; public function assignLicenseToPerson(string $accessToken, Person $person, LicenseDto $license): bool; public function removeLicenseFromPerson(string $accessToken, Person $person, LicenseDto $license): bool; } Note: depending on the situation it's likely the Edit-version always needs to support Listing, so you could opt for EditRemotePersonClientInterface extends ListRemotePeopleClientInterface For the purpose of this presentation they're considered as completed separate. We make sure the supporting clients implement only what they support class \\App\\Clients\\Microsoft implements ListRemotePeopleClientInterface, EditRemoteLicenseClientInterface, ListRemotePeopleClientInterface, EditRemoteLicenseClientInterface { ... } class \\App\\Clients\\Google implements RemotePersonClientInterface { ... } class \\App\\Clients\\Afas implements RemotePersonLicenseInterface { ... } Controllers can fairly easily* be updated class RemoteLicenseController extends Controller { public function index(App\\Person $person, ListRemoteLicensesClientInterface $client): Response { ... } public function create(): Response { ... } public function edit(): Response { ... } public function update(Request $request, EditRemoteLicenseClientInterface $client): Response { ... } } class RemoteLicenseController extends Controller { public function index(App\\Person $person, ListRemoteLicensesClientInterface $client): Response { ... } public function create(): Response { ... } public function edit(): Response { ... } public function update(Request $request, EditRemoteLicenseClientInterface $client): Response { ... } } * Some DI tomfoolery is required, that's for later","title":"Complete separation"},{"location":"4-large-clients/","text":"Microsoft client supports all the features, so it now looks like this namespace \\App\\Clients; class Microsoft implements ListRemotePersonClientInterface, EditRemoteLicenseClientInterface, ListRemotePersonClientInterface, EditRemoteLicenseClientInterface { public function getPeopleInGroup(string $accessToken, Group $group): array { ... } public function createPerson(string $accessToken, PersonDto $person): Person { ... } public function deletePerson(string $accessToken, PersonDto $person): bool { ... } public function updatePerson(string $accessToken, PersonDto $person): bool { ... } public function createPerson(string $accessToken, PersonDto $person): Person { ... } public function deletePerson(string $accessToken, PersonDto $person): bool { ... } public function updatePerson(string $accessToken, PersonDto $person): bool { ... } public function getLicensesForPerson(string $accessToken, Person $person): array { ... } public function createLicense(string $accessToken, LicenseDto $license): License { ... } public function deleteLicense(string $accessToken, LicenseDto $license): bool { ... } public function updateLicense(string $accessToken, LicenseDto $license): boo { ... } public function assignLicenseToPerson(string $accessToken, Person $person, LicenseDto $license): bool { ... } public function removeLicenseFromPerson(string $accessToken, Person $person, LicenseDto $license): bool { ... } } You probably want to separate them as such: namespace \\App\\Clients\\Microsoft; class PersonClient implements ListRemotePeopleClientInterface, EditRemoteLicenseClientInterface { public function getPeopleInGroup(string $accessToken, Group $group): array { ... } public function createPerson(string $accessToken, PersonDto $person): Person { ... } public function deletePerson(string $accessToken, PersonDto $person): bool { ... } public function updatePerson(string $accessToken, PersonDto $person): bool { ... } public function createPerson(string $accessToken, PersonDto $person): Person { ... } public function deletePerson(string $accessToken, PersonDto $person): bool { ... } public function updatePerson(string $accessToken, PersonDto $person): bool { ... } } namespace \\App\\Clients\\Microsoft; class LicenseClient implements ListRemoteLicensesClientInterface, EditRemoteLicenseClientInterface { public function getLicensesForPerson(string $accessToken, Person $person): array { ... } public function createLicense(string $accessToken, LicenseDto $license): License { ... } public function deleteLicense(string $accessToken, LicenseDto $license): bool { ... } public function updateLicense(string $accessToken, LicenseDto $license): boo { ... } public function assignLicenseToPerson(string $accessToken, Person $person, LicenseDto $license): bool { ... } public function removeLicenseFromPerson(string $accessToken, Person $person, LicenseDto $license): bool { ... } } It should not need much change in any application code, only (if any) in the Dependence Injection, in other words in the Service Container setup.","title":"Separate implementation"}]}