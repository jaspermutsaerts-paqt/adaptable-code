{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Adaptable code This talk is focused on backend and its examples are using Laravel. The concepts will translate to any framework and probably applicable to frontend too. I'm using MKdocs so it can serve as both a presentation (with syntax highlighting) and later reference. It does mean there is more text than a presentation should have. What is the goal of this talk? It's meant to inform and inspire. It's not meant to imply anything must be done like this. After this I'd also really like to hear of any other approaches to similar problems.","title":"Home"},{"location":"#adaptable-code","text":"This talk is focused on backend and its examples are using Laravel. The concepts will translate to any framework and probably applicable to frontend too. I'm using MKdocs so it can serve as both a presentation (with syntax highlighting) and later reference. It does mean there is more text than a presentation should have.","title":"Adaptable code"},{"location":"#what-is-the-goal-of-this-talk","text":"It's meant to inform and inspire. It's not meant to imply anything must be done like this. After this I'd also really like to hear of any other approaches to similar problems.","title":"What is the goal of this talk?"},{"location":"0-look-at-this/","text":"Example case Let's say you have a view that will show you some people from a remote source filtered by some scope (a group, for this example). These people come from Microsoft. namespace App\\Controllers; use App\\Models\\Group; use Illuminate\\Http\\Response; use Illuminate\\Routing\\Controller; class RemotePersonController extends Controller { public function index(Group $group, \\Microsoft\\Graph\\Graph $client): Response { $accessToken = 'totally-valid-token'; // pretend-this-has-valid origin /** @var \\Microsoft\\Graph\\Model\\User[] $users */ $users = $client->createRequest('GET', '/people?$filter=groupId eq ' . $group->remote_id) // pretend this is a valid filter ->setAccessToken($accessToken) ->setReturnType(\\Microsoft\\Graph\\Model\\User::class) ->execute(); $people = collect($users)->pluck('displayName', 'id'); return response()->view('person.index', ['people' => $people]); } } What can you think of that you would do differently to this implementation? Shoot.","title":"Look at this"},{"location":"0-look-at-this/#example-case","text":"Let's say you have a view that will show you some people from a remote source filtered by some scope (a group, for this example). These people come from Microsoft. namespace App\\Controllers; use App\\Models\\Group; use Illuminate\\Http\\Response; use Illuminate\\Routing\\Controller; class RemotePersonController extends Controller { public function index(Group $group, \\Microsoft\\Graph\\Graph $client): Response { $accessToken = 'totally-valid-token'; // pretend-this-has-valid origin /** @var \\Microsoft\\Graph\\Model\\User[] $users */ $users = $client->createRequest('GET', '/people?$filter=groupId eq ' . $group->remote_id) // pretend this is a valid filter ->setAccessToken($accessToken) ->setReturnType(\\Microsoft\\Graph\\Model\\User::class) ->execute(); $people = collect($users)->pluck('displayName', 'id'); return response()->view('person.index', ['people' => $people]); } } What can you think of that you would do differently to this implementation?","title":"Example case"},{"location":"0-look-at-this/#shoot","text":"","title":"Shoot."},{"location":"1-first-separation/","text":"Perhaps you prefer to wrap the MS client because you want it to reflect our use case more instead of reflect a Graph API client. class RemotePersonController extends Controller { public function index(Group $group, \\App\\Clients\\Microsoft $client): Response { $accessToken = config('pretend-this-is-always-valid'); /** @var Collection<\\Microsoft\\Graph\\Model\\User> $people */ $users = $client->listUsersInGroup($accessToken, $group); $people = $users->pluck('displayName', 'id'); return response()->view('person.index', ['people' => $people]); } } But now, let's say a requirement for connecting to Google instead of Microsoft is introduced, and (for this example) Google might not call them users. Since we're looking for people not users, we can make interfaces use Person instead of User. We don't need the conversion of users to people in the controller anymore, since the clients are responsible for that class RemotePersonController extends Controller { public function index(Group $group, ClientInterface $client): Response { $people = $client->listPeopleInGroup($accessToken, $group); return response()->view('person.index', ['people' => $people]); } } interface ClientInterface { /** @return PersonDto[] $people */ public function listPeopleInGroup(string $accessToken, Group $group): array; } class \\App\\Clients\\Microsoft implements ClientInterface { ... } class \\App\\Clients\\Google implements ClientInterface { ... }","title":"First separation"},{"location":"10-mocks-vs-fakes/","text":"Using an interface makes it easier to make tests independent of remote connections. You could mock dependencies of course, but there are some disadvantages: Each test (case) is responsible for setting up both expectations and return values It might accept incorrect arguments or return incorrect data Too many mocking might lead to a test only testing itself instead of production code {TODO: Try to think of a concrete example here} class RemotePersonControllerTest extends TestCase { /** @test */ public function it_retrieves_people_from_remote(): void { $clientMock = $this->mock(ListRemotePeopleInterface::class); $clientMock ->expects() ->getLicensesForPerson() ->andReturn([ new Dto\\License('all', 'constructor', 'args'), new Dto\\License('some', 'more', 'args'), ]); } } Fakes are another type of test doubles. They are not mocks, but they \"actually\" work, but usually in a simplified case. In teams I've worked with, we usually called them Fake , but it is also common to namespace or prefix it as InMemory , or even Database . This example just lists the people, or licenses already stored. namespace \\App\\Clients\\Database; class ListPeopleClient implements ListRemotePeopleClient { public function __construct(private readonly string $validAccessToken): { } public function getPeopleInGroup(string $accessToken, Group $person): array { Assert::eq($accessToken, $this->validAccessToken, 'Invalid access token'); Assert::keyExists($person->some_identifier, $this->validAccessToken, 'Unknown group'); $localPeople = Person::whereHasGroup($group) ->whereNotNull('some_identifier') ->get(); $remotePeople = $localPeople->map($this->someTransformation(...)); // still just go with it return $remotePeople; } } namespace \\App\\Clients\\Database; class ListLicenseClient implements ListRemoteLicenseClient { public function __construct(private readonly string $validAccessToken): { } public function getLicensesForPerson(string $accessToken, Person $person): array { Assert::eq($accessToken, $this->validAccessToken, 'Invalid access token'); Assert::keyExists($person->some_identifier, $this->validAccessToken, 'Unknown person'); $localLicenses = $person->licenses; $remoteLicenses = $localLicenses->map($this->someTransformation(...)); return $remoteLicenses; } }","title":"Testing: Mocks vs Fakes"},{"location":"11-mutability-fakes/","text":"Previous example will not work correctly when we expect an update to also be persisted on the remote, but shouldn't change anything locally. Now, what if you want things to be persisted, at least during your tests. Sorry, Not ready namespace \\App\\Clients\\InMemory; class PeopleClient implements ListRemotePeopleClientInterface, EditRemotePersonClient { /** @var Collection<string, Collection<Dto\\Person>> */ private Collection $remotePeopleInGroups; public function __construct(private readonly string $validAccessToken): { $this->remotePeopleInGroups = Groups::whereNotNull('some_identifier') ->mapWithKeys(fn (Group $group) => [ $group->some_identifier => $group->people->map($this->someTransformation(...)); // still going with it? ]); } public function getPeopleInGroup(Group $group): array { Assert::eq($accessToken, $this->validAccessToken, 'Invalid access token'); Assert::true($this->remotePeopleInGroups->has($group->some_identifier), 'Unknown group'); } public function createPerson(PersonDto $person): Person { ... } public function deletePerson(PersonDto $person): bool { ... } public function updatePerson(PersonDto $person): bool { ... } public function createPerson(PersonDto $person): Person { ... } }","title":"Testing: Support mutability in fakes"},{"location":"12-considerations/","text":"Considerations When do you introduce an interface? Always. No, not really. It depends on how interchangeable it likely will be. In case of a client for a remote source, I do it by default, because I'd like to be able to make an offline/in memory version Even if you don't think the remote source will change, API's can change, so you could have an implementation for both versions in a transition period. More than once in my something was \"only needed from remote X\", to later be asked to add it for remote Y too. And sometimes even during development of X I needed to pivot to Y Even during development, I'd like to ask myself this question: If for a specific situation (but not all), some part needs other conditions, another remote source, another remote destination, How much of the application code do I need to change? Try to make those parts separate dependencies (if they aren't already) and try to define them as interfaces. In other words: can you make the application plug & play while maintaining its basic flow/business rules regardless of the implementations? When do you split up your interface into multiple parts? Decide whether all implementations will definitely need to implement all methods, if not: split up. Are you sure the interface serves a single purpose, or is it just that your current intended implementation does all these things? \"We need to at this method to a class, so we need to add it to all its interface's implementations\" That's a good starting point to consider whether the new method is part of the same context of purpose. \"But when all dependencies are interfaces, I can not see what it does!\" Yes you can. As long as we name our interfaces and methods appropriately. namespace App\\Cards; use Webmozart\\Assert\\Assert; class Deck { private array $cards = []; public function __construct( private readonly RandomNumberGeneratorInterface $randomNumberGenerator, ) { } public function drawCard(): Card { Assert::notEmpty($this->cards, 'No cards left in the deck'); $index = $this->randomNumberGenerator->getRandomNumberLessThan(count($this->cards)); $card = $this->cards[$index]; array_splice($this->cards, $index, 1); return $card; } ... Do you really need to see the implementation of RandomNumberGeneratorInterface::getRandomNumberLessThan() to know understand what is going on in drawCard() ? That is only relevant when fixing that dependency, but if that's not reported broken you better believe it returns a random number less than the given argument. Also yes this is a working game: ./artisan app:blackjack","title":"Considerations"},{"location":"12-considerations/#considerations","text":"","title":"Considerations"},{"location":"12-considerations/#when-do-you-introduce-an-interface","text":"Always. No, not really. It depends on how interchangeable it likely will be. In case of a client for a remote source, I do it by default, because I'd like to be able to make an offline/in memory version Even if you don't think the remote source will change, API's can change, so you could have an implementation for both versions in a transition period. More than once in my something was \"only needed from remote X\", to later be asked to add it for remote Y too. And sometimes even during development of X I needed to pivot to Y Even during development, I'd like to ask myself this question: If for a specific situation (but not all), some part needs other conditions, another remote source, another remote destination, How much of the application code do I need to change? Try to make those parts separate dependencies (if they aren't already) and try to define them as interfaces. In other words: can you make the application plug & play while maintaining its basic flow/business rules regardless of the implementations?","title":"When do you introduce an interface?"},{"location":"12-considerations/#when-do-you-split-up-your-interface-into-multiple-parts","text":"Decide whether all implementations will definitely need to implement all methods, if not: split up. Are you sure the interface serves a single purpose, or is it just that your current intended implementation does all these things? \"We need to at this method to a class, so we need to add it to all its interface's implementations\" That's a good starting point to consider whether the new method is part of the same context of purpose.","title":"When do you split up your interface into multiple parts?"},{"location":"12-considerations/#but-when-all-dependencies-are-interfaces-i-can-not-see-what-it-does","text":"Yes you can. As long as we name our interfaces and methods appropriately. namespace App\\Cards; use Webmozart\\Assert\\Assert; class Deck { private array $cards = []; public function __construct( private readonly RandomNumberGeneratorInterface $randomNumberGenerator, ) { } public function drawCard(): Card { Assert::notEmpty($this->cards, 'No cards left in the deck'); $index = $this->randomNumberGenerator->getRandomNumberLessThan(count($this->cards)); $card = $this->cards[$index]; array_splice($this->cards, $index, 1); return $card; } ... Do you really need to see the implementation of RandomNumberGeneratorInterface::getRandomNumberLessThan() to know understand what is going on in drawCard() ? That is only relevant when fixing that dependency, but if that's not reported broken you better believe it returns a random number less than the given argument. Also yes this is a working game: ./artisan app:blackjack","title":"\"But when all dependencies are interfaces, I can not see what it does!\""},{"location":"13-outro/","text":"Conclusion This was just about promoting the use of interfaces. But that's not a catchy title. You can read this back at https://jaspermutsaerts-paqt.github.io/adaptable-code or check out the repository at https://github.com/jaspermutsaerts-paqt/adaptable-code Thoughts?","title":"Conclusion"},{"location":"13-outro/#conclusion","text":"This was just about promoting the use of interfaces. But that's not a catchy title. You can read this back at https://jaspermutsaerts-paqt.github.io/adaptable-code or check out the repository at https://github.com/jaspermutsaerts-paqt/adaptable-code","title":"Conclusion"},{"location":"13-outro/#thoughts","text":"","title":"Thoughts?"},{"location":"2-separate-interfaces-subject/","text":"A concept called Licenses is introduced, so we add a license method to the client interface class RemoteLicenseController extends Controller { public function index(App\\Person $person, ClientInterface $client): Response { $licenses = $client->getLicensesForPerson($person); return response()->view('license.index', ['licenses' => $licenses]); } } interface ClientInterface { /** @return PersonDto[] */ public function getPeopleInGroup(Group $group): array; /** @return LicenseDto[] */ public function getLicensesForPerson(Person $person): array; } class \\App\\Clients\\Microsoft implements ClientInterface { ... } class \\App\\Clients\\Google implements ClientInterface { ... } But, our customer using Google people uses Licenses from a different source, for example AFAS. We actually don't have a case for Google Licenses at the moment. So, we split them up per subject: interface RemotePersonClientInterface { /** @return PersonDto[] */ public function getPeopleInGroup(Group $group): array; } interface RemoteLicensesClientInterface { /** @return LicenseDto[] $licenses */ public function getLicensesForPerson(Person $person): array; } class \\App\\Clients\\Microsoft implements RemotePersonClientInterface, RemoteLicensesClientInterface { ... } class \\App\\Clients\\Google implements RemotePersonClientInterface { ... } class \\App\\Clients\\Afas implements RemoteLicensesClientInterface { ... }","title":"Second separation"},{"location":"3-separate-interfaces-functionality/","text":"Jump in time, we have all remote CRUD methods now, so we have a controller like this class RemoteLicenseController extends Controller { public function index(App\\Person $person, RemotePersonClientInterface $client): Response { ... } public function create(): Response { .. } public function store(Request $request, RemotePersonClientInterface $client): Response { $licenseDto = $this->someTransformation($request); // just go with it ... $license = $client->createLicense($licenseDto); return response()->redirect('license.index'); } public function edit(): Response { .. } public function update(Request $request, RemotePersonClientInterface $client): Response { .. } } We update our client interfaces accordingly: interface RemotePersonClientInterface { public function createPerson(string PersonDto $person): Person; public function updatePerson(string PersonDto $person): bool; public function deletePerson(string PersonDto $person): bool; /** @return PersonDto[] $people */ public function getPeopleInGroup(string Group $group): array; } interface RemoteLicensesClientInterface { public function createLicense(string LicenseDto $license): License; public function updateLicense(string LicenseDto $license): bool; public function deleteLicense(string LicenseDto $license): bool; public function assignLicenseToPerson(string Person $person, LicenseDto $license): bool; public function removeLicenseFromPerson(string Person $person, LicenseDto $license): bool; /** @return LicenseDto[] $licenses */ public function getLicensesForPerson(string Person $person): array; } But, when we want to implement those methods, we realize we don't want to support CRUD methods for AFAS Licenses, nor for Google People. All customers using those, handle their updating outside of our application, not much sense writing support for it just to comply with the interfaces. We can split up the interfaces for their specific use cases interface ListRemotePeopleClientInterface { /** @return PersonDto[] $people */ public function getPeopleInGroup(string Group $group): array; } interface ListRemoteLicensesClientInterface { /** @return LicenseDto[] $licenses */ public function getLicensesForPerson(string Person $person): array; } interface EditRemotePersonClientInterface { public function createPerson(string PersonDto $person): Person; public function updatePerson(string PersonDto $person): bool; public function deletePerson(string PersonDto $person): bool; } interface EditRemoteLicenseClientInterface { public function createLicense(string LicenseDto $license): License; public function updateLicense(string LicenseDto $license): bool; public function deleteLicense(string LicenseDto $license): bool; public function assignLicenseToPerson(string Person $person, LicenseDto $license): bool; public function removeLicenseFromPerson(string Person $person, LicenseDto $license): bool; } Note: depending on the situation it's likely the Edit-version always needs to support Listing, so you could opt for EditRemotePersonClientInterface extends ListRemotePeopleClientInterface For the purpose of this presentation they're considered as completed separate. We make sure the supporting clients implement only what they support class \\App\\Clients\\Microsoft implements ListRemotePeopleClientInterface, EditRemoteLicenseClientInterface, ListRemotePeopleClientInterface, EditRemoteLicenseClientInterface { ... } class \\App\\Clients\\Google implements RemotePersonClientInterface { ... } class \\App\\Clients\\Afas implements RemotePersonLicenseInterface { ... } Controllers can fairly easily* be updated class RemoteLicenseController extends Controller { public function index(App\\Person $person, ListRemoteLicensesClientInterface $client): Response { ... } public function create(): Response { ... } public function edit(): Response { ... } public function update(Request $request, EditRemoteLicenseClientInterface $client): Response { ... } } class RemoteLicenseController extends Controller { public function index(App\\Person $person, ListRemoteLicensesClientInterface $client): Response { ... } public function create(): Response { ... } public function edit(): Response { ... } public function update(Request $request, EditRemoteLicenseClientInterface $client): Response { ... } } * Some DI tomfoolery is required, that's for later","title":"Complete separation"},{"location":"4-large-clients/","text":"Microsoft client supports all the features, so it now looks like this namespace \\App\\Clients; class Microsoft implements ListRemotePersonClientInterface, EditRemoteLicenseClientInterface, ListRemotePersonClientInterface, EditRemoteLicenseClientInterface { public function getPeopleInGroup(Group $group): array { ... } public function createPerson(PersonDto $person): Person { ... } public function deletePerson(PersonDto $person): bool { ... } public function updatePerson(PersonDto $person): bool { ... } public function createPerson(PersonDto $person): Person { ... } public function deletePerson(PersonDto $person): bool { ... } public function updatePerson(PersonDto $person): bool { ... } public function getLicensesForPerson(Person $person): array { ... } public function createLicense(LicenseDto $license): License { ... } public function deleteLicense(LicenseDto $license): bool { ... } public function updateLicense(LicenseDto $license): boo { ... } public function assignLicenseToPerson(Person $person, LicenseDto $license): bool { ... } public function removeLicenseFromPerson(Person $person, LicenseDto $license): bool { ... } } You probably want to separate them as such: namespace \\App\\Clients\\Microsoft; class PersonClient implements ListRemotePeopleClientInterface, EditRemoteLicenseClientInterface { public function getPeopleInGroup(Group $group): array { ... } public function createPerson(PersonDto $person): Person { ... } public function deletePerson(PersonDto $person): bool { ... } public function updatePerson(PersonDto $person): bool { ... } public function createPerson(PersonDto $person): Person { ... } public function deletePerson(PersonDto $person): bool { ... } public function updatePerson(PersonDto $person): bool { ... } } namespace \\App\\Clients\\Microsoft; class LicenseClient implements ListRemoteLicensesClientInterface, EditRemoteLicenseClientInterface { public function getLicensesForPerson(Person $person): array { ... } public function createLicense(LicenseDto $license): License { ... } public function deleteLicense(LicenseDto $license): bool { ... } public function updateLicense(LicenseDto $license): boo { ... } public function assignLicenseToPerson(Person $person, LicenseDto $license): bool { ... } public function removeLicenseFromPerson(Person $person, LicenseDto $license): bool { ... } } It should not need much change in any application code, only (if any) in the Dependence Injection, in other words in the Service Container setup.","title":"Separate implementation"}]}