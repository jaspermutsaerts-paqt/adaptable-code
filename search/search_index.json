{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Adaptable code This talk is focused on backend and its examples are using Laravel. The concepts will translate to any framework and probably applicable to frontend too. I'm using MKdocs so it can serve as both a presentation (with syntax highlighting) and later reference. It does mean there is more text than a presentation should have. What is the goal of this talk? It's meant to inform and inspire. It's not meant to imply anything must be done like this. After this I'd also really like to hear of any other approaches to similar problems.","title":"Home"},{"location":"#adaptable-code","text":"This talk is focused on backend and its examples are using Laravel. The concepts will translate to any framework and probably applicable to frontend too. I'm using MKdocs so it can serve as both a presentation (with syntax highlighting) and later reference. It does mean there is more text than a presentation should have.","title":"Adaptable code"},{"location":"#what-is-the-goal-of-this-talk","text":"It's meant to inform and inspire. It's not meant to imply anything must be done like this. After this I'd also really like to hear of any other approaches to similar problems.","title":"What is the goal of this talk?"},{"location":"0-look-at-this/","text":"Example case Let's say you have a view that will show you some people from a remote source filtered by some scope (a group, for this example). These people come from Microsoft. namespace App\\Controllers; use App\\Models\\Group; use Illuminate\\Http\\Response; use Illuminate\\Routing\\Controller; class RemotePersonController extends Controller { public function index(Group $group, \\Microsoft\\Graph\\Graph $client): Response { $accessToken = 'totally-valid-token'; // pretend-this-has-valid origin /** @var \\Microsoft\\Graph\\Model\\User[] $users */ $users = $client->createRequest('GET', '/people?$filter=groupId eq ' . $group->remote_id) // pretend this is a valid filter ->setAccessToken($accessToken) ->setReturnType(\\Microsoft\\Graph\\Model\\User::class) ->execute(); $people = collect($users)->pluck('displayName', 'id'); return response()->view('person.index', ['people' => $people]); } } What can you think of that you would do differently to this implementation? Shoot.","title":"Look at this"},{"location":"0-look-at-this/#example-case","text":"Let's say you have a view that will show you some people from a remote source filtered by some scope (a group, for this example). These people come from Microsoft. namespace App\\Controllers; use App\\Models\\Group; use Illuminate\\Http\\Response; use Illuminate\\Routing\\Controller; class RemotePersonController extends Controller { public function index(Group $group, \\Microsoft\\Graph\\Graph $client): Response { $accessToken = 'totally-valid-token'; // pretend-this-has-valid origin /** @var \\Microsoft\\Graph\\Model\\User[] $users */ $users = $client->createRequest('GET', '/people?$filter=groupId eq ' . $group->remote_id) // pretend this is a valid filter ->setAccessToken($accessToken) ->setReturnType(\\Microsoft\\Graph\\Model\\User::class) ->execute(); $people = collect($users)->pluck('displayName', 'id'); return response()->view('person.index', ['people' => $people]); } } What can you think of that you would do differently to this implementation?","title":"Example case"},{"location":"0-look-at-this/#shoot","text":"","title":"Shoot."},{"location":"1-first-separation/","text":"Perhaps you prefer to wrap the MS client because you want it to reflect our use case more instead of reflect a Graph API client. class RemotePersonController extends Controller { public function index(Group $group, \\App\\Clients\\Microsoft $client): Response { /** @var Collection<\\Microsoft\\Graph\\Model\\User> $people */ $users = $client->listUsersInGroup($group); $people = $users->pluck('displayName', 'id'); return response()->view('person.index', ['people' => $people]); } } But now, let's say a requirement for connecting to Google instead of Microsoft is introduced, and (for this example) Google might not call them users. Since we're looking for people not users, we can make interfaces use Person instead of User. We don't need the conversion of users to people in the controller anymore, since the clients are responsible for that. class RemotePersonController extends Controller { public function index(Group $group, ClientInterface $client): Response { $people = $client->listPeopleInGroup($group); return response()->view('person.index', ['people' => $people]); } } interface ClientInterface { /** @return PersonDto[] $people */ public function listPeopleInGroup(Group $group): array; } class \\App\\Clients\\Microsoft implements ClientInterface { ... } class \\App\\Clients\\Google implements ClientInterface { ... }","title":"First separation"},{"location":"13-outro/","text":"Conclusion This was just about promoting the use of interfaces and in particular splitting them up. But that's not a catchy title. Thoughts? You can read this back at https://jaspermutsaerts-paqt.github.io/adaptable-code or check out the repository at https://github.com/jaspermutsaerts-paqt/adaptable-code","title":"Conclusion"},{"location":"13-outro/#conclusion","text":"This was just about promoting the use of interfaces and in particular splitting them up. But that's not a catchy title.","title":"Conclusion"},{"location":"13-outro/#thoughts","text":"You can read this back at https://jaspermutsaerts-paqt.github.io/adaptable-code or check out the repository at https://github.com/jaspermutsaerts-paqt/adaptable-code","title":"Thoughts?"},{"location":"2-separate-interfaces-subject/","text":"A concept called Licenses is introduced, so we add a license method to the client interface class RemoteLicenseController extends Controller { public function index(App\\Person $person, ClientInterface $client): Response { $licenses = $client->getLicensesForPerson($person); return response()->view('license.index', ['licenses' => $licenses]); } } interface ClientInterface { /** @return PersonDto[] */ public function getPeopleInGroup(Group $group): array; /** @return LicenseDto[] */ public function getLicensesForPerson(Person $person): array; } class \\App\\Clients\\Microsoft implements ClientInterface { ... } class \\App\\Clients\\Google implements ClientInterface { ... } But, our customer using Google people uses Licenses from a different source, for example AFAS. We actually don't have a case for Google Licenses at the moment. So, we split them up per subject: interface RemotePersonClientInterface { /** @return PersonDto[] */ public function getPeopleInGroup(Group $group): array; } interface RemoteLicensesClientInterface { /** @return LicenseDto[] $licenses */ public function getLicensesForPerson(Person $person): array; } class \\App\\Clients\\Microsoft implements RemotePersonClientInterface, RemoteLicensesClientInterface { ... } class \\App\\Clients\\Google implements RemotePersonClientInterface { ... } class \\App\\Clients\\Afas implements RemoteLicensesClientInterface { ... }","title":"Second separation"},{"location":"3-separate-interfaces-functionality/","text":"Jump in time, we have all remote CRUD methods now, so we have a controller like this class RemoteLicenseController extends Controller { public function index(App\\Person $person, RemoteLicenseClientInterface $client): Response { ... } public function create(): Response { .. } public function store(Request $request, RemoteLicenseClientInterface $client): Response { $licenseDto = $this->someTransformation($request); // just go with it ... $license = $client->createLicense($licenseDto); return response()->redirect('license.index'); } public function edit(): Response { .. } public function update(Request $request, RemoteLicenseClientInterface $client): Response { .. } } We update our client interfaces accordingly: interface RemotePersonClientInterface { public function createPerson(string PersonDto $person): Person; public function updatePerson(string PersonDto $person): bool; public function deletePerson(string PersonDto $person): bool; /** @return PersonDto[] $people */ public function getPeopleInGroup(string Group $group): array; } interface RemoteLicensesClientInterface { public function createLicense(string LicenseDto $license): License; public function updateLicense(string LicenseDto $license): bool; public function deleteLicense(string LicenseDto $license): bool; public function assignLicenseToPerson(string Person $person, LicenseDto $license): bool; public function removeLicenseFromPerson(string Person $person, LicenseDto $license): bool; /** @return LicenseDto[] $licenses */ public function getLicensesForPerson(string Person $person): array; } But, when we want to implement those methods, we realize we don't want to support CRUD methods for AFAS Licenses, nor for Google People. All customers using those, handle their updating outside of our application, not much sense writing support for it just to comply with the interfaces. We can split up the interfaces for their specific use cases interface ListRemotePersonClientInterface { /** @return PersonDto[] $people */ public function getPeopleInGroup(string Group $group): array; } interface ListRemoteLicensesClientInterface { /** @return LicenseDto[] $licenses */ public function getLicensesForPerson(string Person $person): array; } interface EditRemotePersonClientInterface { public function createPerson(string PersonDto $person): Person; public function updatePerson(string PersonDto $person): bool; public function deletePerson(string PersonDto $person): bool; } interface EditRemoteLicenseClientInterface { public function createLicense(string LicenseDto $license): License; public function updateLicense(string LicenseDto $license): bool; public function deleteLicense(string LicenseDto $license): bool; public function assignLicenseToPerson(string Person $person, LicenseDto $license): bool; public function removeLicenseFromPerson(string Person $person, LicenseDto $license): bool; } Note: depending on the situation it's likely the Edit-version always needs to support Listing, so you could opt for EditRemotePersonClientInterface extends ListRemotePersonClientInterface For the purpose of this presentation they're considered as completed separate. We make sure the supporting clients implement only what they support class \\App\\Clients\\Microsoft implements ListRemotePersonClientInterface, EditRemoteLicenseClientInterface, ListRemotePersonClientInterface, EditRemoteLicenseClientInterface { ... } class \\App\\Clients\\Google implements RemotePersonClientInterface { ... } class \\App\\Clients\\Afas implements RemotePersonLicenseInterface { ... } Controllers can fairly easily* be updated class RemoteLicenseController extends Controller { public function index(App\\Person $person, ListRemoteLicensesClientInterface $client): Response { ... } public function create(): Response { ... } public function edit(): Response { ... } public function update(Request $request, EditRemoteLicenseClientInterface $client): Response { ... } } class RemoteLicenseController extends Controller { public function index(App\\Person $person, ListRemoteLicensesClientInterface $client): Response { ... } public function create(): Response { ... } public function edit(): Response { ... } public function update(Request $request, EditRemoteLicenseClientInterface $client): Response { ... } } * Some DI tomfoolery is required, that's for later","title":"Complete separation"},{"location":"4-large-clients/","text":"Microsoft client supports all the features, so it now looks like this namespace \\App\\Clients; class Microsoft implements ListRemotePersonClientInterface, EditRemoteLicenseClientInterface, ListRemotePersonClientInterface, EditRemoteLicenseClientInterface { public function getPeopleInGroup(Group $group): array { ... } public function createPerson(PersonDto $person): Person { ... } public function deletePerson(PersonDto $person): bool { ... } public function updatePerson(PersonDto $person): bool { ... } public function createPerson(PersonDto $person): Person { ... } public function deletePerson(PersonDto $person): bool { ... } public function updatePerson(PersonDto $person): bool { ... } public function getLicensesForPerson(Person $person): array { ... } public function createLicense(LicenseDto $license): License { ... } public function deleteLicense(LicenseDto $license): bool { ... } public function updateLicense(LicenseDto $license): boo { ... } public function assignLicenseToPerson(Person $person, LicenseDto $license): bool { ... } public function removeLicenseFromPerson(Person $person, LicenseDto $license): bool { ... } } That is one long class. You might want to separate them as such: namespace \\App\\Clients\\Microsoft; class PersonClient implements ListRemotePersonClientInterface, EditRemoteLicenseClientInterface { public function getPeopleInGroup(Group $group): array { ... } public function createPerson(PersonDto $person): Person { ... } public function deletePerson(PersonDto $person): bool { ... } public function updatePerson(PersonDto $person): bool { ... } public function createPerson(PersonDto $person): Person { ... } public function deletePerson(PersonDto $person): bool { ... } public function updatePerson(PersonDto $person): bool { ... } } namespace \\App\\Clients\\Microsoft; class LicenseClient implements ListRemoteLicensesClientInterface, EditRemoteLicenseClientInterface { public function getLicensesForPerson(Person $person): array { ... } public function createLicense(LicenseDto $license): License { ... } public function deleteLicense(LicenseDto $license): bool { ... } public function updateLicense(LicenseDto $license): boo { ... } public function assignLicenseToPerson(Person $person, LicenseDto $license): bool { ... } public function removeLicenseFromPerson(Person $person, LicenseDto $license): bool { ... } } It should not need much change in any application code, only (if any) in the Dependence Injection, in other words in the Service Container setup.","title":"Separate implementation"},{"location":"considerations/cant-see-implementation/","text":"Considerations \"But when all dependencies are interfaces, I can not see what it does!\" Yes you can. As long as we name our interfaces and methods appropriately. namespace App\\Cards; use Webmozart\\Assert\\Assert; class Deck { private array $cards = []; public function __construct( private readonly RandomNumberGeneratorInterface $randomNumberGenerator, ) { } public function drawCard(): Card { Assert::notEmpty($this->cards, 'No cards left in the deck'); $index = $this->randomNumberGenerator->getRandomNumberLessThan(count($this->cards)); $card = $this->cards[$index]; array_splice($this->cards, $index, 1); return $card; } ... Do you really need to see the implementation of RandomNumberGeneratorInterface::getRandomNumberLessThan() to know understand what is going on in drawCard() ? That is only relevant when fixing that dependency, but if that's not reported broken you better believe it returns a random number less than the given argument. Also yes this is a working game: ./artisan app:blackjack","title":"But I can't see"},{"location":"considerations/cant-see-implementation/#considerations","text":"","title":"Considerations"},{"location":"considerations/cant-see-implementation/#but-when-all-dependencies-are-interfaces-i-can-not-see-what-it-does","text":"Yes you can. As long as we name our interfaces and methods appropriately. namespace App\\Cards; use Webmozart\\Assert\\Assert; class Deck { private array $cards = []; public function __construct( private readonly RandomNumberGeneratorInterface $randomNumberGenerator, ) { } public function drawCard(): Card { Assert::notEmpty($this->cards, 'No cards left in the deck'); $index = $this->randomNumberGenerator->getRandomNumberLessThan(count($this->cards)); $card = $this->cards[$index]; array_splice($this->cards, $index, 1); return $card; } ... Do you really need to see the implementation of RandomNumberGeneratorInterface::getRandomNumberLessThan() to know understand what is going on in drawCard() ? That is only relevant when fixing that dependency, but if that's not reported broken you better believe it returns a random number less than the given argument. Also yes this is a working game: ./artisan app:blackjack","title":"\"But when all dependencies are interfaces, I can not see what it does!\""},{"location":"considerations/when-introduce/","text":"Considerations When do you introduce an interface? Always. No, not really. It depends on how interchangeable it likely will be. In case of a client for a remote source, I do it by default, because I'd like to be able to make an offline/in memory version Even if you don't think the remote source will change, API's can change, so you could have an implementation for both versions in a transition period. More than once in my something was \"only needed from remote X\", to later be asked to add it for remote Y too. And sometimes even during development of X I needed to pivot to Y Even during development, I'd like to ask myself this question: If for a specific situation (but not all), some part needs other conditions, another remote source, another remote destination, How much of the application code do I need to change? Try to make those parts separate dependencies (if they aren't already) and try to define them as interfaces. In other words: can you make the application plug & play while maintaining its basic flow/business rules regardless of the implementations?","title":"When to introduce"},{"location":"considerations/when-introduce/#considerations","text":"","title":"Considerations"},{"location":"considerations/when-introduce/#when-do-you-introduce-an-interface","text":"Always. No, not really. It depends on how interchangeable it likely will be. In case of a client for a remote source, I do it by default, because I'd like to be able to make an offline/in memory version Even if you don't think the remote source will change, API's can change, so you could have an implementation for both versions in a transition period. More than once in my something was \"only needed from remote X\", to later be asked to add it for remote Y too. And sometimes even during development of X I needed to pivot to Y Even during development, I'd like to ask myself this question: If for a specific situation (but not all), some part needs other conditions, another remote source, another remote destination, How much of the application code do I need to change? Try to make those parts separate dependencies (if they aren't already) and try to define them as interfaces. In other words: can you make the application plug & play while maintaining its basic flow/business rules regardless of the implementations?","title":"When do you introduce an interface?"},{"location":"considerations/when-split/","text":"Considerations When do you split up your interface into multiple parts? Decide whether all implementations will definitely need to implement all methods, if not: split up. Are you sure the interface serves a single purpose, or is it just that your current intended implementation does all these things? \"We need to at this method to a class, so we need to add it to all its interface's implementations\" That's a good starting point to consider whether the new method is part of the same context of purpose.","title":"When to split up"},{"location":"considerations/when-split/#considerations","text":"","title":"Considerations"},{"location":"considerations/when-split/#when-do-you-split-up-your-interface-into-multiple-parts","text":"Decide whether all implementations will definitely need to implement all methods, if not: split up. Are you sure the interface serves a single purpose, or is it just that your current intended implementation does all these things? \"We need to at this method to a class, so we need to add it to all its interface's implementations\" That's a good starting point to consider whether the new method is part of the same context of purpose.","title":"When do you split up your interface into multiple parts?"},{"location":"testing/fakes-database/","text":"Fakes: Database namespace \\App\\Clients\\Database; class ListPersonClient implements ListRemotePersonClient { /** @return PersonDto[] */ public function getPeopleInGroup(Group $group): array { Assert::notNull($group->some_identifier, 'Unknown group'); $people = $group->people() ->whereNotNull('some_identifier') ->chunkMap( fn (Person $person) => $this->personTransformer->transformRecord($person->attributesToArray()) ); return $people->all(); } } use App\\Clients\\Database\\ListPersonClient as DatabaseListPersonClient; class RemotePersonControllerTest extends TestCase { #[Test] public function it_gets_people_from_group_using_database_fake(): void { $this->instance(ListRemotePersonClientInterface::class, app(DatabaseListPersonClient::class)); $groupWithPeople = Group::factory() ->hasAttached(Person::factory(['name' => 'John'])) ->hasAttached(Person::factory(['name' => 'Jackie'])) ->createOne(); $otherGroupWithPeople = Group::factory() ->hasAttached(Person::factory(['name' => 'James'])) ->createOne(); $groupWithoutPeople = Group::factory()->createOne(); $groupNotOnRemote = Group::factory()->createOne(['some_identifier' => null]); $this->get(route('person.group', $groupWithPeople)) ->assertSeeInOnrder(['John', 'Jackie']); $this->get(route('person.group', $otherGroupWithPeople)) ->assertSee(['James']); $this->get(route('person.group', $groupWithoutPeople)) ->assertSee(['No people found in group.']); // Fails with clear exception: unknown group $this->get(route('person.group', $groupNotOnRemote)) ->assertSee(['No people found in group.']); } }","title":"Fake: Database"},{"location":"testing/fakes-database/#fakes-database","text":"namespace \\App\\Clients\\Database; class ListPersonClient implements ListRemotePersonClient { /** @return PersonDto[] */ public function getPeopleInGroup(Group $group): array { Assert::notNull($group->some_identifier, 'Unknown group'); $people = $group->people() ->whereNotNull('some_identifier') ->chunkMap( fn (Person $person) => $this->personTransformer->transformRecord($person->attributesToArray()) ); return $people->all(); } } use App\\Clients\\Database\\ListPersonClient as DatabaseListPersonClient; class RemotePersonControllerTest extends TestCase { #[Test] public function it_gets_people_from_group_using_database_fake(): void { $this->instance(ListRemotePersonClientInterface::class, app(DatabaseListPersonClient::class)); $groupWithPeople = Group::factory() ->hasAttached(Person::factory(['name' => 'John'])) ->hasAttached(Person::factory(['name' => 'Jackie'])) ->createOne(); $otherGroupWithPeople = Group::factory() ->hasAttached(Person::factory(['name' => 'James'])) ->createOne(); $groupWithoutPeople = Group::factory()->createOne(); $groupNotOnRemote = Group::factory()->createOne(['some_identifier' => null]); $this->get(route('person.group', $groupWithPeople)) ->assertSeeInOnrder(['John', 'Jackie']); $this->get(route('person.group', $otherGroupWithPeople)) ->assertSee(['James']); $this->get(route('person.group', $groupWithoutPeople)) ->assertSee(['No people found in group.']); // Fails with clear exception: unknown group $this->get(route('person.group', $groupNotOnRemote)) ->assertSee(['No people found in group.']); } }","title":"Fakes: Database"},{"location":"testing/fakes-in-memory/","text":"Fakes: In Memory namespace \\App\\Clients\\Fake; class ListLicenseClient implements RemoteLicenseClientInterface { /** * @param array<string, LicenseDto> $licensesPerPerson */ public function __construct(private array $licensesPerPerson) { } public function getLicensesForPerson(Person $person): array { Assert::keyExists($person->some_identifier, 'Unknown person'); return $this->licensesPerPerson[$person->some_identifier]; } } use App\\Clients\\Fake\\ListLicenseClient as FakeLicenseClient; class RemotePersonControllerTest extends TestCase { ... #[Test] public function it_gets_licenses_for_person(): void { // This setup could be done outside of the test(case) $licenses = [ $this->personWithLicenses->id => [ new LicenseDto('111111', 'person1-license-1'), new LicenseDto('122222', 'person1-license-2'), ], $this->otherPersonWithLicenses->id => [ new LicenseDto('211111', 'person2-license-1'), new LicenseDto('222222', 'person2-license-2'), ], ]; $this->instance(ListRemoteLicenseClientInterface::class, new FakeLicenseClient($licenses)); $this->get(route('license.index', $this->personWithLicenses)) ->assertSeeInOrder(['person1-license-1', 'person1-license-2']); $this->get(route('license.index', $this->otherPersonWithLicenses)) ->assertSeeInOrder(['person2-license-1', 'person2-license-2']); // Fails with clear exception: unknown person $this->get(route('license.index', $this->personNotOnRemote)) ->assertSee('No licenses found.'); } }","title":"Fake: In Memory"},{"location":"testing/fakes-in-memory/#fakes-in-memory","text":"namespace \\App\\Clients\\Fake; class ListLicenseClient implements RemoteLicenseClientInterface { /** * @param array<string, LicenseDto> $licensesPerPerson */ public function __construct(private array $licensesPerPerson) { } public function getLicensesForPerson(Person $person): array { Assert::keyExists($person->some_identifier, 'Unknown person'); return $this->licensesPerPerson[$person->some_identifier]; } } use App\\Clients\\Fake\\ListLicenseClient as FakeLicenseClient; class RemotePersonControllerTest extends TestCase { ... #[Test] public function it_gets_licenses_for_person(): void { // This setup could be done outside of the test(case) $licenses = [ $this->personWithLicenses->id => [ new LicenseDto('111111', 'person1-license-1'), new LicenseDto('122222', 'person1-license-2'), ], $this->otherPersonWithLicenses->id => [ new LicenseDto('211111', 'person2-license-1'), new LicenseDto('222222', 'person2-license-2'), ], ]; $this->instance(ListRemoteLicenseClientInterface::class, new FakeLicenseClient($licenses)); $this->get(route('license.index', $this->personWithLicenses)) ->assertSeeInOrder(['person1-license-1', 'person1-license-2']); $this->get(route('license.index', $this->otherPersonWithLicenses)) ->assertSeeInOrder(['person2-license-1', 'person2-license-2']); // Fails with clear exception: unknown person $this->get(route('license.index', $this->personNotOnRemote)) ->assertSee('No licenses found.'); } }","title":"Fakes: In Memory"},{"location":"testing/mocks-vs-fakes/","text":"Mocks vs Fakes Using an interface makes it easier to make tests independent of remote connections. You could mock dependencies of course, but there are some disadvantages. Mocking Each test (case) is responsible for setting up both expectations and return values It might accept incorrect arguments or return incorrect data Too many mocking might lead to a test only testing itself instead of production code class RemotePersonControllerTest extends TestCase { #[Test] public function it_gets_licenses_for_person(): void { $licenses = [ new LicenseDto('111111', 'person1-license-1'), new LicenseDto('122222', 'person1-license-2'), ]; $this->mock(RemoteLicenseClientInterface::class) ->expects('getLicensesForPerson') ->andReturn($licenses); $this->get(route('license.index', $this->personWithLicenses)) ->assertSeeInOrder(['person1-license-1', 'person1-license-2']); $licenses = [ new LicenseDto('211111', 'person2-license-1'), new LicenseDto('222222', 'person2-license-2'), ]; $this->mock(RemoteLicenseClientInterface::class) ->expects('getLicensesForPerson') ->andReturn($licenses); // What will go wrong here? $this->get(route('license.index', $this->personWithLicenses)) ->assertSeeInOrder(['person2-license-1', 'person2-license-2']); // What will go wrong here? $this->get(route('license.index', $this->personNotOnRemote)) ->assertSee('No licenses found.'); } } Fakes Fakes are another type of test doubles. They are not mocks, but they \"actually\" work, but usually in a simplified case. In teams I've worked with, we usually called them Fake , but it is also common to namespace or prefix it as InMemory , or even Database , depending on how they work. Depending on the implementation you could even just consider them just alternative drivers.","title":"Mocks vs Fakes"},{"location":"testing/mocks-vs-fakes/#mocks-vs-fakes","text":"Using an interface makes it easier to make tests independent of remote connections. You could mock dependencies of course, but there are some disadvantages.","title":"Mocks vs Fakes"},{"location":"testing/mocks-vs-fakes/#mocking","text":"Each test (case) is responsible for setting up both expectations and return values It might accept incorrect arguments or return incorrect data Too many mocking might lead to a test only testing itself instead of production code class RemotePersonControllerTest extends TestCase { #[Test] public function it_gets_licenses_for_person(): void { $licenses = [ new LicenseDto('111111', 'person1-license-1'), new LicenseDto('122222', 'person1-license-2'), ]; $this->mock(RemoteLicenseClientInterface::class) ->expects('getLicensesForPerson') ->andReturn($licenses); $this->get(route('license.index', $this->personWithLicenses)) ->assertSeeInOrder(['person1-license-1', 'person1-license-2']); $licenses = [ new LicenseDto('211111', 'person2-license-1'), new LicenseDto('222222', 'person2-license-2'), ]; $this->mock(RemoteLicenseClientInterface::class) ->expects('getLicensesForPerson') ->andReturn($licenses); // What will go wrong here? $this->get(route('license.index', $this->personWithLicenses)) ->assertSeeInOrder(['person2-license-1', 'person2-license-2']); // What will go wrong here? $this->get(route('license.index', $this->personNotOnRemote)) ->assertSee('No licenses found.'); } }","title":"Mocking"},{"location":"testing/mocks-vs-fakes/#fakes","text":"Fakes are another type of test doubles. They are not mocks, but they \"actually\" work, but usually in a simplified case. In teams I've worked with, we usually called them Fake , but it is also common to namespace or prefix it as InMemory , or even Database , depending on how they work. Depending on the implementation you could even just consider them just alternative drivers.","title":"Fakes"},{"location":"testing/mutability-fakes/","text":"Making fakes work with good mutability is harder, but not impossible. I wanted to put some examples here, but it was hard to make it not too complex. There are some considerations: unique value generation for create-methods If you use database as a source for your fake, an update to sync remote with local won't do anything. It's easy to make it work in a flow, but hard to make it useful. An in-memory solution like a simple array is easier to implement, but gets tricky when you need to maintain relations.","title":"Fake: Support mutability"}]}